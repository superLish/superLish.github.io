<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://superlish.github.io/superLish.github.io/</id><title>ChirpyLi</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-03-15T17:46:30+08:00</updated> <author> <name>lisheng</name> <uri>https://superlish.github.io/superLish.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://superlish.github.io/superLish.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en-US" href="https://superlish.github.io/superLish.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 lisheng </rights> <icon>/superLish.github.io/assets/img/favicons/favicon.ico</icon> <logo>/superLish.github.io/assets/img/favicons/favicon-96x96.png</logo> <entry><title>为什么要构建自己的博客</title><link href="https://superlish.github.io/superLish.github.io/posts/why-build-my-own-blog/" rel="alternate" type="text/html" title="为什么要构建自己的博客" /><published>2021-02-08T20:55:00+08:00</published> <updated>2021-02-17T16:41:16+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/why-build-my-own-blog/</id> <content src="https://superlish.github.io/superLish.github.io/posts/why-build-my-own-blog/" /> <author> <name>lisheng</name> </author> <category term="Blogging" /> <category term="Diary" /> <summary> 为什么要构建自己的博客 之前一直在CSDN上写博客，也写了好久，但是CSDN的问题就是商业化气息太浓重了，个人比较喜欢简洁一些的风格。也在微信公众号上写了若干，但总觉得维护起来比较麻烦，尤其是想修改原文的时候。恰逢农历年因疫情原因不能回家，就有了一个构建自己的博客的想法，且趁这段时间将以前的博文梳理迁移过来,。 我对自己博客的想法就是，简洁，便于维护，方便归档查询。最终决定采用Github+Jekyll构建自己的博客，在theme中选取了自己喜欢的Chirpy。按照Chaipy-REAMDE文档的说明以及参考Working with GitHub Pages一步步构建出来。 Ready, Go! </summary> </entry> <entry><title>Rust异步之自己构造block_on</title><link href="https://superlish.github.io/superLish.github.io/posts/Rust%E5%BC%82%E6%AD%A5%E4%B9%8B%E8%87%AA%E5%B7%B1%E6%9E%84%E9%80%A0block_on/" rel="alternate" type="text/html" title="Rust异步之自己构造block_on" /><published>2021-02-05T20:55:00+08:00</published> <updated>2021-02-05T20:55:00+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/Rust%E5%BC%82%E6%AD%A5%E4%B9%8B%E8%87%AA%E5%B7%B1%E6%9E%84%E9%80%A0block_on/</id> <content src="https://superlish.github.io/superLish.github.io/posts/Rust%E5%BC%82%E6%AD%A5%E4%B9%8B%E8%87%AA%E5%B7%B1%E6%9E%84%E9%80%A0block_on/" /> <author> <name>lisheng</name> </author> <category term="CS" /> <category term="Rust" /> <summary> 一个block_on代码示例 我们在进行异步编程时，经常会有下面形式的代码： use tokio::time::Duration; fn main() { let runtime = tokio::runtime::Builder::new_multi_thread() .enable_all() .build().unwrap(); runtime.block_on(hello()); } async fn hello() { tokio::time::sleep(Duration::from_secs(3)).await; println!("hello world."); } 我们看一下tokio中关于block_on的定义： /// Run a future to completion on the T... </summary> </entry> <entry><title>Rust中的Arc与Rc</title><link href="https://superlish.github.io/superLish.github.io/posts/Rust%E4%B8%AD%E7%9A%84Arc%E4%B8%8ERc/" rel="alternate" type="text/html" title="Rust中的Arc与Rc" /><published>2020-11-23T20:55:00+08:00</published> <updated>2020-11-23T20:55:00+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/Rust%E4%B8%AD%E7%9A%84Arc%E4%B8%8ERc/</id> <content src="https://superlish.github.io/superLish.github.io/posts/Rust%E4%B8%AD%E7%9A%84Arc%E4%B8%8ERc/" /> <author> <name>lisheng</name> </author> <category term="CS" /> <category term="Rust" /> <summary> Rc 单线程引用计数。不是线程安全的，如果需要线程间引用计数可用Arc。注意他们之间的实现区别。关键源码实现如下，重点可关注Clone和Drop以及new的实现细节。 //! Single-threaded reference-counting pointers. 'Rc' stands for 'Reference Counted'. // This is repr(C) to future-proof against possible field-reordering, which // would interfere with otherwise safe [into|from]_raw() of transmutable inner types. #[repr(C)] struct RcBox&amp;lt;T: ?Sized&amp;gt; { strong: Cell&amp;lt;u... </summary> </entry> <entry><title>树堆</title><link href="https://superlish.github.io/superLish.github.io/posts/%E6%A0%91%E5%A0%86/" rel="alternate" type="text/html" title="树堆" /><published>2020-06-15T08:55:00+08:00</published> <updated>2020-06-15T08:55:00+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/%E6%A0%91%E5%A0%86/</id> <content src="https://superlish.github.io/superLish.github.io/posts/%E6%A0%91%E5%A0%86/" /> <author> <name>lisheng</name> </author> <category term="CS" /> <category term="数据结构与算法" /> <summary> 树堆 树堆，是一种将二叉查找（搜索）树与堆两种数据结构结合在一起的一种数据结构，它首先是一颗二叉查找树同时满足一定的堆性质。我们知道二叉查找树与堆性质是有矛盾的，解决办法就是元素值以二叉查找树的性质分布，每个元素插入时都会随机生成一个优先级，优先级要满足堆性质中父节点大于等于子节点的性质，但不要求满足完全二叉树的堆性质。这样做的好处是：使二叉查找树保持一定的平衡性。 树堆的实现 树堆的实现，主要是堆怎么融到二叉查找树中，我们知道维护堆性质，需要经常交换父子节点的值，这里如果直接交换会破坏二叉查找树的性质，怎么办呢？用旋转的方法，交换父子节点的值不是目的，目的是维护堆父节点大于子节点的性质，用旋转的方法同样等做到这一点，同时还保证了二叉查找树的性质。 查找 查找的过程与二叉查找树的查找过程一样，此时忽略优先级。 插入 插入的思路如下：新元素先按其值插入到二叉查找树中，方法... </summary> </entry> <entry><title>PBFT共识算法</title><link href="https://superlish.github.io/superLish.github.io/posts/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="PBFT共识算法" /><published>2020-06-10T13:25:00+08:00</published> <updated>2021-02-22T17:06:40+08:00</updated> <id>https://superlish.github.io/superLish.github.io/posts/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</id> <content src="https://superlish.github.io/superLish.github.io/posts/PBFT%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" /> <author> <name>lisheng</name> </author> <category term="CS" /> <category term="分布式" /> <summary> 拜占庭将军问题 我们已知的共识算法，Paxos、Raft解决的都是非拜占庭问题，也就是可以容忍节点故障，消息丢失、延时、乱序等，但节点不能有恶意节点。但如何在有恶意节点存在的情况下达成共识呢？BFT共识算法就是解决这一问题的。即不但能容忍节点故障，还能容忍一定的恶意节点或者说拜占庭节点的存在。我们下面就学习一下BFT算法中的PBFT（Practical Byzantine Fault Tolerance）。BFT算法有非常多的变种，这里只学习PBFT，其他的可以举一反三。 PBFT PBFT核心由3个协议组成：一致性协议、检查点协议、视图更换协议。系统正常运行在一致性协议和检查点协议下，只有当主节点出错或者运行缓慢的情况下才会启动视图更换协议，以维持系统继续响应客户端的请求。下面详解这3个子协议。在讲一致性协议之前，我们屏蔽算法细节先看一下正常情况下大致是怎么工作的，大致流程如下：... </summary> </entry> </feed>
